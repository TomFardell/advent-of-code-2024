
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <cuda.h>
#include "utils.cuh"

#define INPUT 'p'

#if INPUT == 'p'
#define FILE_NAME "data/08p.txt"
#define N 50
#elif INPUT == 's'
#define FILE_NAME "data/08s.txt"
#define N 12
#endif

#define BLOCK_SIZE 8
#define MAX_SIGNALS 62
#define MAX_SIGNALS_OF_TYPE 4
#define A (1 + 2 * MAX_SIGNALS_OF_TYPE)  // Width of antennae array

__constant__ int antennae_dev[A * MAX_SIGNALS];

__device__ int point_in_bounds(const int i, const int j) {
  return (0 <= i && i < N && 0 <= j && j < N);
}

__global__ void find_antinodes(const int check_on_line, char *antinodes) {
  int idx = (blockIdx.x * blockDim.x) + threadIdx.x;
  if (idx >= MAX_SIGNALS) return;

  int n = antennae_dev[A * idx];
  for (int a1 = 0; a1 < n; a1++) {
    for (int a2 = 0; a2 < n; a2++) {
      if (a1 == a2) continue;
      // Read antennae coordinates
      int a1i = antennae_dev[(2 * a1 + 1) + A * idx];
      int a1j = antennae_dev[(2 * a1 + 2) + A * idx];
      int a2i = antennae_dev[(2 * a2 + 1) + A * idx];
      int a2j = antennae_dev[(2 * a2 + 2) + A * idx];

      // We must have two unique antennae of this type to have gotten here
      if (check_on_line) {
        antinodes[a1i + N * a1j] = 1;
      }

      int pi = a1i, pj = a1j;
      do {
        // Find positions of the antinode. Since we loop over each pair of indices twice, we do in
        // fact find both antinodes generated by this pair
        pi += a1i - a2i;
        pj += a1j - a2j;

        // Check if antinode is on the grid. If so, set to 1 on the map. Note that we could have two
        // threads trying to write to the same memory, but this doesn't matter since both are
        // setting it to 1
        if (point_in_bounds(pi, pj)) antinodes[pi + N * pj] = 1;
      } while (check_on_line && point_in_bounds(pi, pj));
    }
  }
}
int signal_index(const char signal) {
  if (signal == '.') return -1;
  if (signal >= 'a') return signal - 'a';
  if (signal >= 'A') return signal - 'A' + 26;
  return signal - '0' + 52;
}

int count_antinodes(const char *antinodes) {
  int count = 0;
  for (int i = 0; i < N; i++) {
    for (int j = 0; j < N; j++) {
      if (antinodes[i + N * j]) count++;
    }
  }
  return count;
}

int main(void) {
  int antennae[A * MAX_SIGNALS] = {0};

  FILE *file = fopen(FILE_NAME, "r");
  for (int i = 0; i < N; i++) {
    for (int j = 0; j < N; j++) {
      char c = fgetc(file);
      int idx = signal_index(c);
      if (idx != -1) {
        int n = ++antennae[A * idx];
        antennae[(2 * n - 1) + A * idx] = i;
        antennae[(2 * n) + A * idx] = j;
      }
    }
    fgetc(file);  // Read newline
  }
  fclose(file);

  error_check(cudaMemcpyToSymbol(antennae_dev, antennae, A * MAX_SIGNALS * sizeof(int)));

  char *antinodes_dev;
  error_check(cudaMalloc(&antinodes_dev, N * N * sizeof(char)));
  error_check(cudaMemset(antinodes_dev, 0, N * N * sizeof(char)));

  find_antinodes<<<calculate_num_blocks(BLOCK_SIZE, MAX_SIGNALS), BLOCK_SIZE>>>(0, antinodes_dev);
  error_check(cudaPeekAtLastError());

  char antinodes[N * N];
  error_check(cudaMemcpy(antinodes, antinodes_dev, N * N * sizeof(char), cudaMemcpyDeviceToHost));
  int total = count_antinodes(antinodes);
  printf("%d\n", total);

  // No reason to reset antinodes_dev, since the original antinodes are all still antinodes under
  // these new rules
  find_antinodes<<<calculate_num_blocks(BLOCK_SIZE, MAX_SIGNALS), BLOCK_SIZE>>>(1, antinodes_dev);
  error_check(cudaPeekAtLastError());

  error_check(cudaMemcpy(antinodes, antinodes_dev, N * N * sizeof(char), cudaMemcpyDeviceToHost));
  error_check(cudaFree(antinodes_dev));
  total = count_antinodes(antinodes);
  printf("%d\n", total);

  return 0;
}